
@article{jones1992,
author = {Jones, Peyton and L, Simon and Peyton Jones, Simon},
title = {Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine},
year = {1992},
month = {July},
abstract = {The Spineless Tagless G-machine is an abstract machine designed to support non- strict higher-order functional languages. This presentation of the machine falls into three parts. Firstly, we give a general discussion of the design issues involved in implementing non-strict functional languages.
Next, we present the STG language, an austere but recognisably-functional language, which as well as a denotational meaning has a well-defined operational semantics. The STG language is the \abstract machine code" for the Spineless Tagless G-machine.
Lastly, we discuss the mapping of the STG language onto stock hardware. The success of an abstract machine model depends largely on how efficient this mapping can be made, though this topic is often relegated to a short section. Instead, we give a detailed discussion of the design issues and the choices we have made. Our principal target is the C language, treating the C compiler as a portable assembler.},
publisher = {Cambridge University Press},
url = {https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/},
pages = {127-202},
journal = {Journal of Functional Programming},
volume = {2},
edition = {Journal of Functional Programming},
}

@inproceedings{boquist1996,
author = {Boquist, Urban and Johnsson, Thomas},
title = {The GRIN Project: A Highly Optimising Back End for Lazy Functional Languages},
year = {1996},
isbn = {3540632379},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Selected Papers from the 8th International Workshop on Implementation of Functional Languages},
pages = {58–84},
numpages = {27},
series = {IFL '96}
}

@book{aho2006,
author = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey D.},
title = {Compilers: Principles, Techniques, and Tools (2nd Edition)},
year = {2006},
isbn = {0321486811},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@article{boquist1999,
author = {Boquist, Urban},
year = {1999},
month = {01},
pages = {},
title = {Code optimisation techniques for lazy functional languages}
}


@inproceedings{ullrich2021,
author = {Ullrich, Sebastian and de Moura, Leonardo},
title = {Counting Immutable Beans: Reference Counting Optimized for Purely Functional Programming},
year = {2021},
isbn = {9781450375627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412932.3412935},
doi = {10.1145/3412932.3412935},
booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
articleno = {3},
numpages = {12},
keywords = {lean, reference counting, purely functional programming},
location = {Singapore, Singapore},
series = {IFL '19}
}

@techreport{reinking2020,
author = {Reinking*, Alex and Xie*, Ningning and de Moura, Leonardo and Leijen, Daan},
title = {Perceus: Garbage Free Reference Counting with Reuse (Extended version)},
institution = {Microsoft},
year = {2020},
month = {November},
url = {https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/},
number = {MSR-TR-2020-42},
note = {(*) The first two authors contributed equally to this work. v4, 2021-06-07. Extended version of the PLDI'21 paper.},
}

@article{lorenzen2022,
author = {Lorenzen, Anton and Leijen, Daan},
title = {Reference Counting with Frame Limited Reuse},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547634},
doi = {10.1145/3547634},
journal = {Proc. ACM Program. Lang.},
month = {8},
articleno = {103},
numpages = {24},
keywords = {Frame Limited, Reference Counting, Reuse, Koka}
}

@techreport{lorenzen2023,
author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
title = {FP$^2$: Fully in-Place Functional Programming},
institution = {Microsoft},
year = {2023},
month = {5},
url = {https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming/},
number = {MSR-TR-2023-19},
}

@inproceedings{hage2008,
author = {Hage, Jurriaan and Holdermans, Stefan},
title = {Heap Recycling for Lazy Languages},
year = {2008},
isbn = {9781595939777},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328408.1328436},
doi = {10.1145/1328408.1328436},
abstract = {Pure functional programming languages preclude destructive updates of heap-allocated data. In such languages, all newly computed algebraic values claim freshly allocated heap space, which typically causes idiomatic programs to be notoriously inefficient when compared to their imperative and impure counterparts. We partly overcome this shortcoming by considering a syntactically light language construct for enabling user-controlled in-place updates of algebraic values. The resulting calculus, that is based on a combination of type-based uniqueness and constructor analysis, is guaranteed to maintain referential transparency and is fully compatible with existing run-time systems for nonstrict, pure functional languages.},
booktitle = {Proceedings of the 2008 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
pages = {189–197},
numpages = {9},
keywords = {lazy functional programming, compile-time garbage collection, type-based program analysis},
location = {San Francisco, California, USA},
series = {PEPM '08}
}

@inproceedings{ende2010,
  title={Extending the UHC LLVM backend : Adding support for accurate garbage collection},
  author={P v.d. Ende},
  year={2010}
}

@inproceedings{dijkstra2009,
author = {Dijkstra, Atze and Fokker, Jeroen and Swierstra, S. Doaitse},
title = {The Architecture of the Utrecht Haskell Compiler},
year = {2009},
isbn = {9781605585086},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1596638.1596650},
doi = {10.1145/1596638.1596650},
abstract = {In this paper we describe the architecture of the Utrecht Haskell Compiler (UHC).UHC is a new Haskell compiler, that supports most (but not all) Haskell 98 features, plus some experimental extensions. It targets multiple backends, including a bytecode interpreter backend and a whole-program analysis backend, both via C. The implementation is rigorously organized as stepwise transformations through some explicit intermediate languages. The tree walks of all transformations are expressed as an algebra, with the aid of an Attribute Grammar based preprocessor. The compiler is just one materialization of a framework that supports experimentation with language variants, thanks to an aspect-oriented internal organization.},
booktitle = {Proceedings of the 2nd ACM SIGPLAN Symposium on Haskell},
pages = {93–104},
numpages = {12},
keywords = {aspect orientation, attribute grammar, compiler architecture, haskell},
location = {Edinburgh, Scotland},
series = {Haskell '09}
}

@inproceedings{boeijink2010,
  title={Introducing the PilGRIM: A Processor for Executing Lazy Functional Languages},
  author={Arjan Boeijink and Philip K. F. H{\"o}lzenspies and Jan Kuper},
  booktitle={International Symposium on Implementation and Application of Functional Languages},
  year={2010}
}

@article{johnsson2004,
author = {Johnsson, Thomas},
title = {Efficient Compilation of Lazy Evaluation},
year = {2004},
issue_date = {April 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {4},
issn = {0362-1340},
url = {https://doi.org/10.1145/989393.989409},
doi = {10.1145/989393.989409},
abstract = {This paper describes the principles underlying an efficient implementation of a lazy functional language, compiling to code for ordinary computers. It is based on combinator-like graph reduction: the user defined functions are used as rewrite rules in the graph. Each function is compiled into an instruction sequence for an abstract graph reduction machine, called the G-machine, the code reduces a function application graph to its value. The G-machine instructions are then translated into target code. Speed improvements by almost two orders of magnitude over previous lazy evaluators have been measured; we provide some performance figures.},
journal = {SIGPLAN Not.},
month = {apr},
pages = {125–138},
numpages = {14}
}

@article{podlovics2021,
  title={A Modern Look at GRIN, an Optimizing Functional Language Back End},
  author={P{\'e}ter Podlovics and Csaba Hruska and Andor P{\'e}nzes},
  journal={Acta Cybern.},
  year={2021},
  volume={25},
  pages={847-876}
}

@article{huang2023,
author = {Huang, Yulong and Yallop, Jeremy},
title = {Defunctionalization with Dependent Types},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {PLDI},
url = {https://doi.org/10.1145/3591241},
doi = {10.1145/3591241},
abstract = {The defunctionalization translation that eliminates higher-order functions from programs forms a key part of many compilers. However, defunctionalization for dependently-typed languages has not been formally studied. We present the first formally-specified defunctionalization translation for a dependently-typed language and establish key metatheoretical properties such as soundness and type preservation. The translation is suitable for incorporation into type-preserving compilers for dependently-typed languages},
journal = {Proc. ACM Program. Lang.},
month = {jun},
articleno = {127},
numpages = {23},
keywords = {compilation, type systems, type preservation, dependent types}
}

@article{10.1145/2775050.2633370,
author = {Okabe, Kiwamu and Muranushi, Takayuki},
title = {Systems Demonstration: Writing NetBSD Sound Drivers in Haskell},
year = {2014},
issue_date = {December 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/2775050.2633370},
doi = {10.1145/2775050.2633370},
abstract = {Most strongly typed, functional programming languages are not equipped with a reentrant garbage collector. Therefore such languages are not used for operating systems programming, where the virtues of types are most desired. We propose the use of Context-Local Heaps (CLHs) to achieve reentrancy, which also increasing the speed of garbage collection. We have implemented CLHs in Ajhc, a Haskell compiler derived from jhc, rewritten some NetBSD sound drivers using Ajhc, and benchmarked them. The reentrant, faster garbage collection that CLHs provide opens the path to type-assisted operating systems programming.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {77–78},
numpages = {2},
keywords = {performance, languages}
}

@inproceedings{okabe2014,
author = {Okabe, Kiwamu and Muranushi, Takayuki},
title = {Systems Demonstration: Writing NetBSD Sound Drivers in Haskell},
year = {2014},
isbn = {9781450330411},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2633357.2633370},
doi = {10.1145/2633357.2633370},
abstract = {Most strongly typed, functional programming languages are not equipped with a reentrant garbage collector. Therefore such languages are not used for operating systems programming, where the virtues of types are most desired. We propose the use of Context-Local Heaps (CLHs) to achieve reentrancy, which also increasing the speed of garbage collection. We have implemented CLHs in Ajhc, a Haskell compiler derived from jhc, rewritten some NetBSD sound drivers using Ajhc, and benchmarked them. The reentrant, faster garbage collection that CLHs provide opens the path to type-assisted operating systems programming.},
booktitle = {Proceedings of the 2014 ACM SIGPLAN Symposium on Haskell},
pages = {77–78},
numpages = {2},
keywords = {performance, languages},
location = {Gothenburg, Sweden},
series = {Haskell '14}
}

@article{xi2018,
  author       = {Hongwei Xi and
                  Dengping Zhu},
  title        = {To Memory Safety through Proofs},
  journal      = {CoRR},
  volume       = {abs/1810.12190},
  year         = {2018},
  url          = {http://arxiv.org/abs/1810.12190},
  eprinttype    = {arXiv},
  eprint       = {1810.12190},
  timestamp    = {Thu, 01 Nov 2018 18:03:07 +0100},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1810-12190.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{racordon2022,
  title={Implementation Strategies for Mutable Value Semantics},
  author={Dimitri Racordon and Denys Shabalin and Daniel Zheng and Dave Abrahams and Brennan Saeta},
  journal={J. Object Technol.},
  year={2022},
  volume={21},
  pages={2:1-11},
  url={https://api.semanticscholar.org/CorpusID:248335097}
}
