
@article{jones1992,
author = {Jones, Peyton and L, Simon and Peyton Jones, Simon},
title = {Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine},
year = {1992},
month = {July},
abstract = {The Spineless Tagless G-machine is an abstract machine designed to support non- strict higher-order functional languages. This presentation of the machine falls into three parts. Firstly, we give a general discussion of the design issues involved in implementing non-strict functional languages.
Next, we present the STG language, an austere but recognisably-functional language, which as well as a denotational meaning has a well-defined operational semantics. The STG language is the \abstract machine code" for the Spineless Tagless G-machine.
Lastly, we discuss the mapping of the STG language onto stock hardware. The success of an abstract machine model depends largely on how efficient this mapping can be made, though this topic is often relegated to a short section. Instead, we give a detailed discussion of the design issues and the choices we have made. Our principal target is the C language, treating the C compiler as a portable assembler.},
publisher = {Cambridge University Press},
url = {https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/},
pages = {127-202},
journal = {Journal of Functional Programming},
volume = {2},
edition = {Journal of Functional Programming},
}

@inproceedings{boquist1996,
author = {Boquist, Urban and Johnsson, Thomas},
title = {The GRIN Project: A Highly Optimising Back End for Lazy Functional Languages},
year = {1996},
isbn = {3540632379},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Selected Papers from the 8th International Workshop on Implementation of Functional Languages},
pages = {58–84},
numpages = {27},
series = {IFL '96}
}

@book{aho2006,
author = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey D.},
title = {Compilers: Principles, Techniques, and Tools (2nd Edition)},
year = {2006},
isbn = {0321486811},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@article{boquist1999,
author = {Boquist, Urban},
year = {1999},
month = {01},
pages = {},
title = {Code optimisation techniques for lazy functional languages}
}


@inproceedings{ullrich2021,
author = {Ullrich, Sebastian and de Moura, Leonardo},
title = {Counting Immutable Beans: Reference Counting Optimized for Purely Functional Programming},
year = {2021},
isbn = {9781450375627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412932.3412935},
doi = {10.1145/3412932.3412935},
booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
articleno = {3},
numpages = {12},
keywords = {lean, reference counting, purely functional programming},
location = {Singapore, Singapore},
series = {IFL '19}
}

@techreport{reinking2020,
author = {Reinking*, Alex and Xie*, Ningning and de Moura, Leonardo and Leijen, Daan},
title = {Perceus: Garbage Free Reference Counting with Reuse (Extended version)},
institution = {Microsoft},
year = {2020},
month = {November},
url = {https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/},
number = {MSR-TR-2020-42},
note = {(*) The first two authors contributed equally to this work. v4, 2021-06-07. Extended version of the PLDI'21 paper.},
}

@inproceedings{reinking2021,
author = {Reinking, Alex and Xie, Ningning and de Moura, Leonardo and Leijen, Daan},
title = {Perceus: Garbage Free Reference Counting with Reuse},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454032},
doi = {10.1145/3453483.3454032},
abstract = {We introduce Perceus, an algorithm for precise reference counting with reuse and specialization. Starting from a functional core language with explicit control-flow, Perceus emits precise reference counting instructions such that (cycle-free) programs are _garbage free_, where only live references are retained. This enables further optimizations, like reuse analysis that allows for guaranteed in-place updates at runtime. This in turn enables a novel programming paradigm that we call _functional but in-place_ (FBIP). Much like tail-call optimization enables writing loops with regular function calls, reuse analysis enables writing in-place mutating algorithms in a purely functional way. We give a novel formalization of reference counting in a linear resource calculus, and prove that Perceus is sound and garbage free. We show evidence that Perceus, as implemented in Koka, has good performance and is competitive with other state-of-the-art memory collectors.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {96–111},
numpages = {16},
keywords = {Handlers, Algebraic Effects, Reference Counting},
location = {Virtual, Canada},
series = {PLDI 2021}
}

@article{lorenzen2022,
author = {Lorenzen, Anton and Leijen, Daan},
title = {Reference Counting with Frame Limited Reuse},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547634},
doi = {10.1145/3547634},
journal = {Proc. ACM Program. Lang.},
month = {8},
articleno = {103},
numpages = {24},
keywords = {Frame Limited, Reference Counting, Reuse, Koka}
}

@techreport{lorenzen2023,
author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
title = {FP$^2$: Fully in-Place Functional Programming},
institution = {Microsoft},
year = {2023},
month = {5},
url = {https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming/},
number = {MSR-TR-2023-19},
}

@inproceedings{hage2008,
author = {Hage, Jurriaan and Holdermans, Stefan},
title = {Heap Recycling for Lazy Languages},
year = {2008},
isbn = {9781595939777},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1328408.1328436},
doi = {10.1145/1328408.1328436},
abstract = {Pure functional programming languages preclude destructive updates of heap-allocated data. In such languages, all newly computed algebraic values claim freshly allocated heap space, which typically causes idiomatic programs to be notoriously inefficient when compared to their imperative and impure counterparts. We partly overcome this shortcoming by considering a syntactically light language construct for enabling user-controlled in-place updates of algebraic values. The resulting calculus, that is based on a combination of type-based uniqueness and constructor analysis, is guaranteed to maintain referential transparency and is fully compatible with existing run-time systems for nonstrict, pure functional languages.},
booktitle = {Proceedings of the 2008 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
pages = {189–197},
numpages = {9},
keywords = {lazy functional programming, compile-time garbage collection, type-based program analysis},
location = {San Francisco, California, USA},
series = {PEPM '08}
}

@inproceedings{ende2010,
  title={Extending the UHC LLVM backend : Adding support for accurate garbage collection},
  author={P v.d. Ende},
  year={2010}
}

@inproceedings{dijkstra2009,
author = {Dijkstra, Atze and Fokker, Jeroen and Swierstra, S. Doaitse},
title = {The Architecture of the Utrecht Haskell Compiler},
year = {2009},
isbn = {9781605585086},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1596638.1596650},
doi = {10.1145/1596638.1596650},
abstract = {In this paper we describe the architecture of the Utrecht Haskell Compiler (UHC).UHC is a new Haskell compiler, that supports most (but not all) Haskell 98 features, plus some experimental extensions. It targets multiple backends, including a bytecode interpreter backend and a whole-program analysis backend, both via C. The implementation is rigorously organized as stepwise transformations through some explicit intermediate languages. The tree walks of all transformations are expressed as an algebra, with the aid of an Attribute Grammar based preprocessor. The compiler is just one materialization of a framework that supports experimentation with language variants, thanks to an aspect-oriented internal organization.},
booktitle = {Proceedings of the 2nd ACM SIGPLAN Symposium on Haskell},
pages = {93–104},
numpages = {12},
keywords = {aspect orientation, attribute grammar, compiler architecture, haskell},
location = {Edinburgh, Scotland},
series = {Haskell '09}
}

@inproceedings{boeijink2010,
  title={Introducing the PilGRIM: A Processor for Executing Lazy Functional Languages},
  author={Arjan Boeijink and Philip K. F. H{\"o}lzenspies and Jan Kuper},
  booktitle={International Symposium on Implementation and Application of Functional Languages},
  year={2010}
}

@article{johnsson2004,
author = {Johnsson, Thomas},
title = {Efficient Compilation of Lazy Evaluation},
year = {2004},
issue_date = {April 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {4},
issn = {0362-1340},
url = {https://doi.org/10.1145/989393.989409},
doi = {10.1145/989393.989409},
abstract = {This paper describes the principles underlying an efficient implementation of a lazy functional language, compiling to code for ordinary computers. It is based on combinator-like graph reduction: the user defined functions are used as rewrite rules in the graph. Each function is compiled into an instruction sequence for an abstract graph reduction machine, called the G-machine, the code reduces a function application graph to its value. The G-machine instructions are then translated into target code. Speed improvements by almost two orders of magnitude over previous lazy evaluators have been measured; we provide some performance figures.},
journal = {SIGPLAN Not.},
month = {apr},
pages = {125–138},
numpages = {14}
}

@article{podlovics2021,
  title={A Modern Look at GRIN, an Optimizing Functional Language Back End},
  author={P{\'e}ter Podlovics and Csaba Hruska and Andor P{\'e}nzes},
  journal={Acta Cybern.},
  year={2021},
  volume={25},
  pages={847-876}
}

@article{huang2023,
author = {Huang, Yulong and Yallop, Jeremy},
title = {Defunctionalization with Dependent Types},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {PLDI},
url = {https://doi.org/10.1145/3591241},
doi = {10.1145/3591241},
abstract = {The defunctionalization translation that eliminates higher-order functions from programs forms a key part of many compilers. However, defunctionalization for dependently-typed languages has not been formally studied. We present the first formally-specified defunctionalization translation for a dependently-typed language and establish key metatheoretical properties such as soundness and type preservation. The translation is suitable for incorporation into type-preserving compilers for dependently-typed languages},
journal = {Proc. ACM Program. Lang.},
month = {jun},
articleno = {127},
numpages = {23},
keywords = {compilation, type systems, type preservation, dependent types}
}

@inproceedings{okabe2014,
author = {Okabe, Kiwamu and Muranushi, Takayuki},
title = {Systems Demonstration: Writing NetBSD Sound Drivers in Haskell},
year = {2014},
isbn = {9781450330411},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2633357.2633370},
doi = {10.1145/2633357.2633370},
abstract = {Most strongly typed, functional programming languages are not equipped with a reentrant garbage collector. Therefore such languages are not used for operating systems programming, where the virtues of types are most desired. We propose the use of Context-Local Heaps (CLHs) to achieve reentrancy, which also increasing the speed of garbage collection. We have implemented CLHs in Ajhc, a Haskell compiler derived from jhc, rewritten some NetBSD sound drivers using Ajhc, and benchmarked them. The reentrant, faster garbage collection that CLHs provide opens the path to type-assisted operating systems programming.},
booktitle = {Proceedings of the 2014 ACM SIGPLAN Symposium on Haskell},
pages = {77–78},
numpages = {2},
keywords = {performance, languages},
location = {Gothenburg, Sweden},
series = {Haskell '14}
}

@article{xi2018,
  author       = {Hongwei Xi and
                  Dengping Zhu},
  title        = {To Memory Safety through Proofs},
  journal      = {CoRR},
  volume       = {abs/1810.12190},
  year         = {2018},
  url          = {http://arxiv.org/abs/1810.12190},
  eprinttype    = {arXiv},
  eprint       = {1810.12190},
  timestamp    = {Thu, 01 Nov 2018 18:03:07 +0100},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1810-12190.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{racordon2022,
  title={Implementation Strategies for Mutable Value Semantics},
  author={Dimitri Racordon and Denys Shabalin and Daniel Zheng and Dave Abrahams and Brennan Saeta},
  journal={J. Object Technol.},
  year={2022},
  volume={21},
  pages={2:1-11},
  url={https://api.semanticscholar.org/CorpusID:248335097}
}

@misc{racordon2021,
  title={Native Implementation of Mutable Value Semantics}, 
  author={Dimitri Racordon and Denys Shabalin and Daniel Zheng and Dave Abrahams and Brennan Saeta},
  year={2021},
  eprint={2106.12678},
  archivePrefix={arXiv},
  primaryClass={cs.PL}
}

@inproceedings{boquist1995,
author = {Boquist, Urban},
title = {Interprocedural Register Allocation for Lazy Functional Languages},
year = {1995},
isbn = {0897917197},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/224164.224215},
doi = {10.1145/224164.224215},
booktitle = {Proceedings of the Seventh International Conference on Functional Programming Languages and Computer Architecture},
pages = {270–281},
numpages = {12},
location = {La Jolla, California, USA},
series = {FPCA '95}
}

@article{collins1960,
author = {Collins, George E.},
title = {A Method for Overlapping and Erasure of Lists},
year = {1960},
issue_date = {Dec. 1960},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/367487.367501},
doi = {10.1145/367487.367501},
abstract = {An important property of the Newell Shaw-Simon scheme for computer storage of lists is that data having multiple occurrences need not be stored at more than one place in the computer. That is, lists may be “overlapped.” Unfortunately, overlapping poses a problem for subsequent erasure. Given a list that is no longer needed, it is desired to erase just those parts that do not overlap other lists. In LISP, McCarthy employs an elegant but inefficient solution to the problem. The present paper describes a general method which enables efficient erasure. The method employs interspersed reference counts to describe the extent of the overlapping.},
journal = {Commun. ACM},
month = {dec},
pages = {655–657},
numpages = {3}
}

@article{appel1997, title={Garbage Collection: Algorithms for Automatic Dynamic Memory Management by Richard Jones and Rafael Lins, John Wiley &amp; Sons, 1996.}, volume={7}, DOI={10.1017/S0956796897212682}, number={2}, journal={Journal of Functional Programming}, publisher={Cambridge University Press}, author={APPEL, ANDREW W.}, year={1997}, pages={227–229}}

@book{jones1996,
author = {Jones, Richard and Lins, Rafael},
title = {Garbage Collection: Algorithms for Automatic Dynamic Memory Management},
year = {1996},
isbn = {0471941484},
publisher = {John Wiley \& Sons, Inc.},
address = {USA}
}

@article{peytonjones1992, title={Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine}, volume={2}, DOI={10.1017/S0956796800000319}, number={2}, journal={Journal of Functional Programming}, publisher={Cambridge University Press}, author={Jones, Simon L. Peyton}, year={1992}, pages={127–202}}

@inproceedings{wilson1992,
  title={Uniprocessor Garbage Collection Techniques},
  author={Paul R. Wilson},
  booktitle={IWMM},
  year={1992},
  url={https://api.semanticscholar.org/CorpusID:206841815}
}

@article{pinto2023,
  title={Perceus for OCaml},
  author={Pinto, Elton},
  year={2023},
  url={https://www.eltonpinto.me/assets/work/mthesis-perceus-for-ocaml.pdf}
}
