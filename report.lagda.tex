\documentclass{article}

% Support for Agda code.
\usepackage{agda}

\usepackage{fontspec}
\newfontfamily{\AgdaSerifFont}{Latin Modern Roman}
\newfontfamily{\AgdaSansSerifFont}{Latin Modern Sans}
\newfontfamily{\AgdaTypewriterFont}{Latin Modern Mono}
\renewcommand{\AgdaFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaKeywordFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaStringFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaCommentFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaBoundFontStyle}[1]{\textit{\AgdaSerifFont{}#1}}

% Bibliography
\usepackage[backend=biber, style=apa, natbib=true]{biblatex}
\addbibresource{../bibliography.bib}

% Cosmetics
\linespread{1.25}

\usepackage{newunicodechar}
\usepackage{colonequals}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{∀}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{₁}{\ensuremath{{}_1}}
\newunicodechar{∷}{\ensuremath{\mathnormal{\coloncolon}}}
\newunicodechar{ω}{\ensuremath{\mathnormal{\omega}}}

\title{Optimizing lazy functional languages with precise reference counting}
\author{Martin Fredin}
\date{June 2023}

\begin{document}

\maketitle

\begin{code}[hide]
open import Data.List using (List; _∷_; [])

private 
  variable
    A B : Set

\end{code}

\section{Introduction}

All values in purely functional languages are immutable.
Immutability is important because it limits shared state, and makes it easier to reason about the program.
In practice, this means that a function such as \AgdaFunction{map} returns a new list instead of modifying the input.
\begin{code}
map : (A → B) → List A → List B
map f []       = []
map f (x ∷ xs) = f x ∷ map f xs
\end{code}
This is great if the input list (\AgdaDatatype{List}\AgdaSpace\AgdaGeneralizable{A}) is used later in the program. 
Otherwise, it is better to reuse the allocation for \AgdaDatatype{List}\AgdaSpace\AgdaGeneralizable{A} by updating the list in place. 
This avoids both the deallocation of \AgdaDatatype{List}\AgdaSpace\AgdaGeneralizable{A} and the allocation of \AgdaDatatype{List}\AgdaSpace\AgdaGeneralizable{B}.
To preserve the semantics of the program, destructive updates should only be perfomed on values which are garanteed to be non-shared. 
We call a value shared if there is multiple references to it.

Reference counting \citep{collins1960} is a memory management technique which can detect and free resources as soon as they are no longer needed, allowing memory reuse and destructive updates. 
Common reference counting algorithms are easy to implement; each allocation contains an extra field which tracks the number of references to a value, and reclaims the heap space once the reference count drops to zero. 
As a result of the interleaved collection strategy, memory usage remain low and the throughput is continuous throughout the computation\footnote{Not entirely true.} \citep{jones1996}.
However, ...

\begin{itemize}
\item Lower throughput than tracing GC
\item Not very good at handling short lived values which is most values (especially in pure FP)
\item \citet{reinking2021} and \citet{ullrich2021} minimize RC operations through precise reference counting and a linear calculus.
\item more...
\end{itemize}








%\citet{ullrich2021} uses reference counting with 

%borrowed references in the Lean programming language. Their algorithm 

%\citet{reinking2021} 

%Both Lean and Koka are, however, eagerly evaluated. Lazy languages...


\section{Graph Reduction Intermediate Notation}

\section{Extending GRIN with reference counting}

\section{Result}

\section{Relevant Work}
% Lean and Koka: reference counting and reuse
% Swift: automatic reference counting (ARC), and plans of borrowing
% AST \& Rust: safe manual memory management through proofs and the borrow checker, respectively

\section{Conclusion and Future Work}
\begin{itemize}
\item Add reuse and borrowing
\item Utilse GRIN's whole program compilation strategy and the heap points-to analysis to statically determine unshared values during compile time, and thus minimizing the number of reference countinging operations.
\item It would also be intresting to utilse 0-modality (erasure) in Agda's type system, and later also 1-modality when Agda gets it.
\end{itemize}

% Lambda lifting
% The rest of the GRIN transformations and optimizations
% Partial applications (P-tags and the apply operation)
% Different allocator? mimalloc?
% Using type information (multiplicites: 0, (1), ω)

\printbibliography

\end{document}

